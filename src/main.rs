mod schema;

use anyhow::{Context, Result, anyhow};
use clap::{Parser, Subcommand};
use schema::{Registry, Theme, Profile};
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[command(name = "HRM", version = "0.1.0", about = "HyprRice Manager")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build the config for a specific profile
    Build {
        /// The name of the profile (without .toml)
        #[arg(short, long)]
        profile: String,

        /// Optional: Override the root config directory (Default: ~/.config/hypr)
        #[arg(long)]
        root: Option<String>,
    },
}

// Default production path
const DEFAULT_ROOT: &str = ".";

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Build { profile, root } => handle_build(&profile, root),
    }
}

fn handle_build(profile_name: &str, custom_root: Option<String>) -> Result<()> {
    // 1. Determine the Root Path
    let raw_root = custom_root.unwrap_or_else(|| DEFAULT_ROOT.to_string());
    let root_expanded = shellexpand::tilde(&raw_root).to_string();
    let root_path = Path::new(&root_expanded);

    // Verify root exists
    if !root_path.exists() {
        return Err(anyhow!("Root directory does not exist: {:?}", root_path));
    }

    println!(">> üèóÔ∏è  Starting Build");
    println!("   üìÇ Root: {:?}", root_path);
    println!("   üë§ Profile: '{}'", profile_name);

    // 2. Load the Registry
    let reg_path = root_path.join("catalog/registry.toml");
    let registry: Registry = read_toml(&reg_path)?;
    println!("   ‚úÖ Loaded Registry ({} static, {} tunable)", 
        registry.static_modules.len(), registry.tunable_modules.len());

    // 3. Load the Profile
    let profile_path = root_path.join("profiles").join(format!("{}.toml", profile_name));
    let profile: Profile = read_toml(&profile_path)?;
    println!("   ‚úÖ Loaded Profile (Base: '{}')", profile.base_theme);

    // 4. Load the Base Theme
    let theme_path = root_path.join("themes").join(format!("{}.toml", profile.base_theme));
    let theme: Theme = read_toml(&theme_path)?;
    println!("   ‚úÖ Loaded Theme '{}'", theme.meta.name);

    // --- RESOLUTION LOGIC ---
    let mut final_paths: Vec<String> = Vec::new();

    // A. Resolve Static Requirements
    // FIX: Iterate directly over the vector. If it's empty, the loop just won't run.
    for req_id in &theme.static_reqs {
        let entry = registry.static_modules.get(req_id)
            .ok_or_else(|| anyhow!("Theme requires static module '{}', but it is not in registry!", req_id))?;
        final_paths.push(entry.path.clone());
    }

    // B. Resolve Slots
    for (slot_name, slot_def) in &theme.slots {
        let logical_id = if let Some(override_id) = profile.overrides.get(slot_name) {
            println!("      üîπ Slot '{}': Overridden with '{}'", slot_name, override_id);
            override_id
        } else {
            println!("      üî∏ Slot '{}': Using default '{}'", slot_name, slot_def.default);
            &slot_def.default
        };

        let entry = registry.tunable_modules.get(logical_id)
            .ok_or_else(|| anyhow!("Registry missing ID '{}' (required for slot '{}')", logical_id, slot_name))?;
        
        final_paths.push(entry.path.clone());
    }

    // --- GENERATION ---
    println!(">> üìù Generating config...");
    
    let mut output_content = String::from("# -----------------------------------------------------\n");
    output_content.push_str(&format!("# AUTO-GENERATED BY HYPR-RICE-MANAGER\n"));
    output_content.push_str(&format!("# Profile: {}\n", profile_name));
    output_content.push_str(&format!("# Theme:   {}\n", theme.meta.name));
    output_content.push_str("# -----------------------------------------------------\n\n");

    for path in final_paths {
        let abs_path = root_path.join(&path);
        if !abs_path.exists() {
            eprintln!("   ‚ö†Ô∏è  Warning: Config file not found at {:?}", abs_path);
        }
        output_content.push_str(&format!("source = {}\n", abs_path.to_string_lossy()));
    }

    let output_path = root_path.join("generated/active_session.conf");
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(&output_path, output_content)?;
    
    println!(">> ‚úÖ Successfully wrote to {:?}", output_path);
    
    Ok(())
}

fn read_toml<T: serde::de::DeserializeOwned>(path: &PathBuf) -> Result<T> {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read file: {:?}", path))?;
    toml::from_str(&content)
        .with_context(|| format!("Failed to parse TOML: {:?}", path))
}
