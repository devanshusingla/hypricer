mod schema;

use anyhow::{Context, Result, anyhow};
use clap::{Parser, Subcommand};
use schema::{Registry, Theme, Profile};
use std::fs;
use std::path::{Path, PathBuf};
use regex::Regex;

#[derive(Parser)]
#[command(name = "HRM", version = "0.4.0")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Build {
        #[arg(short, long)]
        profile: String,
        #[arg(long)]
        root: Option<String>,
    },
}

const DEFAULT_ROOT: &str = ".";

fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Build { profile, root } => handle_build(&profile, root),
    }
}

fn handle_build(profile_name: &str, custom_root: Option<String>) -> Result<()> {
    // 1. Setup Root Path
    let raw_root = custom_root.unwrap_or_else(|| DEFAULT_ROOT.to_string());
    let root_expanded = shellexpand::tilde(&raw_root).to_string();
    let root_path = Path::new(&root_expanded);

    if !root_path.exists() {
        return Err(anyhow!("Root directory does not exist: {:?}", root_path));
    }
    println!(">> ðŸ—ï¸  Starting Build (Template Mode)");
    println!("   ðŸ“‚ Root: {:?}", root_path);

    // 2. Load Data Files
    let registry: Registry = read_toml(&root_path.join("catalog/registry.toml"))?;
    let profile: Profile = read_toml(&root_path.join("profiles").join(format!("{}.toml", profile_name)))?;
 
    let theme_path = root_path
        .join("themes")
        .join(&profile.base_theme) // "modern_dark"
        .join("theme.toml");       // "theme.toml"

    let theme: Theme = read_toml(&theme_path)
        .with_context(|| format!("Theme not found at {:?}", theme_path))?;   
    println!("   âœ… Loaded Theme '{}'", theme.meta.name);

    // 3. Read the Template File
    let template_path = root_path.join(&theme.template);
    let template_content = fs::read_to_string(&template_path)
        .with_context(|| format!("Failed to read Template at {:?}", template_path))?;

    // 4. Process Template with Regex
    // Pattern: Finds "{{ some_text }}" on its own line
    let re = Regex::new(r"(?m)^\s*\{\{\s*([a-zA-Z0-9_]+)\s*\}\}\s*$")?;
    
    let mut new_content = String::from("# AUTO-GENERATED BY HRM\n");
    new_content.push_str(&format!("# Profile: {}\n", profile_name));
    new_content.push_str("# ------------------------------------------\n");

    let processed_body = re.replace_all(&template_content, |caps: &regex::Captures| {
        let key = &caps[1]; 

        // --- RESOLUTION LOGIC ---

        // A. Is it a SLOT? (Tunable / Dynamic)
        if let Some(slot_def) = theme.slots.get(key) {
             let logical_id = if let Some(usr_ovr) = profile.overrides.get(key) {
                 println!("      ðŸ”¹ Slot '{}': Override -> '{}'", key, usr_ovr);
                 usr_ovr
             } else {
                 println!("      ðŸ”¸ Slot '{}': Default -> '{}'", key, &slot_def.default);
                 &slot_def.default
             };
             
             // Verify existence in Registry
             match registry.tunable_modules.get(logical_id) {
                 Some(entry) => format_source(&root_path, &entry.path),
                 None => {
                     eprintln!("   âŒ CRITICAL: Slot ID '{}' missing from Registry!", logical_id);
                     format_error(key, "MISSING REGISTRY ENTRY")
                 }
             }
        } 
        
        // B. Is it a STATIC MAP? (Local Name -> Global ID)
        else if let Some(global_id) = theme.static_map.get(key) {
             println!("      â–ªï¸ Static '{}' -> Global ID '{}'", key, global_id);
             
             // Verify existence in Registry
             match registry.static_modules.get(global_id) {
                 Some(entry) => format_source(&root_path, &entry.path),
                 None => {
                     eprintln!("   âŒ CRITICAL: Static ID '{}' missing from Registry!", global_id);
                     format_error(key, "MISSING REGISTRY ENTRY")
                 }
             }
        }

        // C. Undefined
        else {
             eprintln!("   âŒ ERROR: Tag '{{ {} }}' not found in Theme TOML!", key);
             format_error(key, "UNDEFINED IN THEME")
        }
    });

    new_content.push_str(&processed_body);

    // 5. Write Result
    let output_path = root_path.join("generated/active_session.conf");
    if let Some(parent) = output_path.parent() { fs::create_dir_all(parent)?; }
    fs::write(&output_path, new_content)?;

    println!(">> âœ… Generated: {:?}", output_path);
    Ok(())
}

// --- Helpers ---

fn format_source(root: &Path, rel_path: &str) -> String {
    let abs_path = root.join(rel_path);
    format!("source = {}", abs_path.to_string_lossy())
}

fn format_error(key: &str, msg: &str) -> String {
    format!("# ERROR [{{ {} }}]: {}", key, msg)
}

fn read_toml<T: serde::de::DeserializeOwned>(path: &PathBuf) -> Result<T> {
    let content = fs::read_to_string(path).with_context(|| format!("Failed to read {:?}", path))?;
    toml::from_str(&content).with_context(|| format!("Failed to parse {:?}", path))
}
